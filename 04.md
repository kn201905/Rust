// 実験のため、Copy trait だけが欲しいが、
// pub trait Copy: Clone { ...
// となってるため、Clone も実装させる。
#[derive(Copy, Clone, Debug)]
//#[derive(Debug)]
struct Point {
	x: i32,
	y: i32,
}

impl Point {
	fn consume_move(mut self) {
		self.x = 100;
		println!("consume_move: {:?}", self);
	}
	
	fn ref_move(&mut self) {
		self.x = 100;
		println!("ref_move: {:?}", self);
	}
}

fn main() {
	let color = "green";
	print_type_of(color);  //「&str」が表示される
	
	// `println!` は参照により機能することに留意
	let print = || println!("color: {}", color);
	print();
	println!();

	// ------------------------------------
	let mut count = 0;

	// `inc`には`mut`をつける必要がある。なぜならミュータブルな型が
	// このクロージャは内部変数を変更するため、mut を付与する
	let mut inc = || {
		count += 1;
		println!("inc: {}", count);
	};
	inc();

	// inc() で &mut count されているため、以下はエラー。
	// let _reborrow = &count; 

	inc();
	
	// ここでは &count を取得可能
	let _reborrow = &count; 

	println!("count: {}", count);

	// A non-copy type.
	let movable = Box::new(3);

	// mem::drop は参照ではなく、値そのものを取る
	let consume = || {
		println!("`movable`: {:?}", movable);
		std::mem::drop(movable);
	};

	consume();
	// 以下は、当然エラー
	// consume();
	
	// ------------------------------------
	println!();
	
	let mut pt = Point { x: 1, y: 2};
	
	let consume_pt = || {
		// pt は copyable であるため、copy が生成されて consume が実行される
		// Point::consume_move(pt); の糖衣構文であるため、このような奇妙なことが起きる
		pt.consume_move();
		println!("{:?}", pt);
	};
	consume_pt();
	
	println!("\n{:?}", pt);
	
	pt.ref_move();
	println!("{:?}", pt);
}

fn print_type_of<T>(_: T) {
    println!("{}", std::any::type_name::<T>())
}
